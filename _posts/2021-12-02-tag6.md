---
title: "Tag 6 â€“ Metadaten modellieren und Schnittstellen nutzen (1/2)"
date: 2021-12-02
---
Tag 6 â€“ Metadaten modellieren und Schnittstellen nutzen (1/2)

Ein neuer Vorlesungstag steht vor der TÃ¼r. Dieses Mal geht es um die Modellierung von Metadaten und die Nutzung von entsprechenden Schnittstellen, um Metadaten auszutauschen.
In den bisherigen Vorlesungen waren Metadaten bereits ein wichtiger Bestandteil, sei es bei Bibliotheks- und Archivsystemen, wie auch bei Repositorysoftware. Heute soll dieses
Thema also vertieft betrachtet werden. 

Als erstes jedoch wurden noch zwei andere Fragen geklÃ¤rt. Zum einen was sogenannte Â«Persistent IdentifierÂ» sind 
und wie diese vergeben werden. Die wohl bekanntesten Persistent Identifiers sind die sog. Â«Digital Object IdentifierÂ» (DOI), mit welchen digital verfÃ¼gbaren Ressourcen wie 
wissenschaftliche Artikel oder Journals ausgezeichnet werden. Die DOIs haben den Vorteil, dass diese technische VerÃ¤nderungen Ã¼berstehen, ohne ihre GÃ¼ltigkeit zu verlieren. 
Die DOIs werden von verschiedenen Organisationen verwaltet, die VerfÃ¼gbarkeit der Ressource liegt jedoch in der Verantwortung der Institution, welche die Ressource verÃ¶ffentlicht. 
Die zweite Frage bezog sich auf den Sinn von Sub-Communities bei DSpace. Die Dozierenden erklÃ¤rten dies anhand eines Anschauungsbeispiels ziemlich gut, wie ich fand. 

Danach ging es mit dem eigentlichen Thema dieser Vorlesung weiter. Dabei wurde als erstes nochmals auf folgende Darstellung Bezug genommen: 

![image](https://user-images.githubusercontent.com/81507183/150560365-42037f30-77a5-407d-a77f-b1f93733b35b.png)

Wie man sieht, haben wir bereits vieles davon kennengelernt, sowohl auf Seiten der Systeme als auch bei den Metadatenstandards. Was nun noch fehlt, ist die Verbindung dazwischen. 
Die oben gezeigte Schnittstelle OAI-PMH haben wir bereits bei der letzten Ãœbung gesehen. Weitere Protokolle, mit welchen Metadaten zwischen Systemen Ã¼bertragen werden, 
sind Z39.50 und SRU. Diese eignen sich vor allem fÃ¼r die Abfrage von spezifischen Metadaten und bei Live-Abfragen. Bei grÃ¶sseren Datenmengen ist OAI-PMH der gÃ¤ngige Standard. 
Was nun noch fehlt, ist das Tool fÃ¼r das Harvesting, das Â«ErntenÂ» der Metadaten. HierfÃ¼r wurde uns das Tool Â«VuFindHarvestÂ», mit welchem Metadaten von OAI-PMH-Schnittstellen 
bezogen werden kÃ¶nnen, vorgestellt. Dazu musste wiederum eine Installation auf der virtuellen Maschine vorgenommen werden. Nachdem dies geschehen war, konnte die Ernte beginnen. 
DafÃ¼r musste man folgenden Befehl in der Shell nutzen: 

php bin/harvest_oai.php --url=http://example.com/oai_server -- metadataPrefix=oai_dc my_target_dir

NatÃ¼rlich musste man den Befehl noch auf die eigene Abfrage anpassen. DafÃ¼r musste man die URL des Systems, den Metadatenstandard der Daten, sowie den Ablageort, wo man die 
geernteten Daten haben mÃ¶chte, Ã¤ndern. In unserer Ãœbung sollten wir Metadaten von Koha und Archivespace abfragen. Hier hatte ich anfangs etwas MÃ¼he, da ich keinen separaten 
Ablageordner erstellt hatte, nach einiger Zeit aber hatte ich das Prinzip verstanden. 

Der zweite grosse Aspekt dieser Vorlesung waren sogenannte Â«CrosswalksÂ», die Konvertierung von einem Metadatenformat in ein anderes. Die grosse Herausforderung hierbei ist, 
dass diese Konvertierung verlustfrei geschieht, was leider nicht immer der Fall ist. Umgesetzt wird dies mittels der Programmiersprache Â«XSLTÂ». Als Tool hierfÃ¼r nutzten wir 
die Open-Source-Software Â«MarcEdit 7Â», welche sehr hÃ¤ufig im Umgang mit MARC21 eingesetzt wird, passend zum obigen Schaubild. Da wir es bei uns mit einer Linux-Distribution 
zu tun hatten, mussten wir erst noch einige Konfigurationen vornehmen, damit das Tool in dieser Umgebung auch richtig funktionierte. Anschliessend sollten wir selbststÃ¤ndig
die zuvor bearbeiteten Daten aus Archivespace, sowie DSpace, in MARC21XML konvertieren. Aus Bequemlichkeit entschied ich mich dazu, die alternativ bereitgestellten 
Beispielsdaten zu nutzen. FÃ¼r die Konvertierung der EAD-Daten war ein Zwischenschritt nÃ¶tig (EAD -> MARC21, MARC21 -> MARC21XML). Dies funktionierte gut, das Prinzip dahinter 
war verstÃ¤ndlich. 

So, dass war es fÃ¼r heute, bis zum nÃ¤chsten Mal ğŸ˜Š
